/*
 * Copyright (c) 2021, Irvin Pang <halo.irvin@gmail.com>
 * All rights reserved.
 * 
 * see LICENSE file for details
 */

import protobuf from 'protobufjs';
import { VERSION_STR } from './version';
import { SimpleCodeGen } from './codegen';

interface IOptions {
    create?: boolean;
    decode?: boolean;
    encode?: boolean;
    delimited?: boolean;
    verify?: boolean;
    convert?: boolean;
    es6?: boolean;
    root?: string;
    comments?: boolean;
    forceLong?: boolean;
    forceNumber?: boolean;
    forceMessage?: boolean;
    forceEnumString?: boolean;
}

const PROTOBUF          = 'protobuf',
      ROOT              = '$root',
      READER_FUNCTIONS  = '$reader',
      WRITER_FUNCTIONS  = '$writer',
      TYPES_ARRAY       = '$types',
      WIRES_ARRAY       = '$wires',
      PACKED_ARRAY      = '$packed',
      READER_SKIP       = '$rskip',
      WRITER_LDELIM     = '$wldelim',
      WRITER_FORK       = '$wfork',
      RW_WRAP           = '$',
      CLASS_NAME        = 'C',
      PROPERTIES        = 'props',
      TYPE              = 'type',
      NAMESPACE         = 'namespace',
      PARENT            = 'parent',
      KEYS              = 'keys',
      KEY               = 'key',
      FIELD_PAYLOADS    = 'payloads',
      FIELD_PAYLOAD     = 'payload',
      READER            = 'reader',
      WRITER            = 'writer',
      LENGTH            = 'length',
      END_POS           = 'end',
      MESSAGE           = 'message',
      TAG               = 'tag',
      FIELD             = 'field',
      FIELD_ID          = 'id',
      WIRE              = 'wire',
      REPEATED_FIELD    = 'array',
      PATH              = 'path',
      IS_PACKED         = 'packed';

const DEFAULT_ROOT = 'default';

let config: IOptions;

function static_mini(root: protobuf.Root, options: IOptions, callback: Function): void {
    config = options;
    root.name = root.name || config.root || DEFAULT_ROOT;
    let codeGen = new SimpleCodeGen(4);
    // global definition
    codeGen
        .pushLine("/**")
        .pushLine(" * DO NOT EDIT")
        .pushLine(" * -- this file is generated by minipbjs v%s", VERSION_STR)
        .pushLine(" */ ")
        .pushLine()
        // appending to root namespace from protobuf
        .pushLine("var %s = %s.roots;", ROOT, PROTOBUF)
        .pushLine()
        .pushLine("// type system from %s", PROTOBUF)
        .pushLine("// notice: minimal build protobuf library does not contains 'types'")
        .pushLine("var %s = %s.types ? %s.types.basic : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0, 'string': 2, 'bytes': 2 };", WIRES_ARRAY, PROTOBUF, PROTOBUF)
        .pushLine("var %s = %s.types ? %s.types.packed : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0 };", PACKED_ARRAY, PROTOBUF, PROTOBUF)
        .pushLine("var %s = Object.keys(%s);", TYPES_ARRAY, WIRES_ARRAY)
        .pushLine()
        // shorthands & alias & wrapper
        .pushLine("// shorthands")
        .pushLine("var %s = %s.Reader.prototype.skipType;", READER_SKIP.padEnd(8), PROTOBUF)
        .pushLine("var %s = %s.Writer.prototype.ldelim;", WRITER_LDELIM.padEnd(8), PROTOBUF)
        .pushLine("var %s = %s.Writer.prototype.fork;", WRITER_FORK.padEnd(8), PROTOBUF)
        .pushLine()
        .pushLine("var %s = {", READER_FUNCTIONS).addIndent()
            // reader wrapper for all types
            .pushLine("['%s']: function(%s) {", RW_WRAP, TYPE).addIndent()
                .pushLine("return %s[%s] ? %s[%s].call(this) : %s[%s].decode(this, this.uint32());", READER_FUNCTIONS, TYPE, READER_FUNCTIONS, TYPE, ROOT, TYPE).subIndent()
            .pushLine("}").subIndent()
        .pushLine("}, %s = {", WRITER_FUNCTIONS).addIndent()
            // writer wrapper for all types
            .pushLine("['%s']: function(%s, %s, %s) {", RW_WRAP, TYPE, MESSAGE, FIELD_ID).addIndent()
                .pushLine("var %s = %s[%s];", WIRE, WIRES_ARRAY, TYPE)
                .pushLine("return (%s === undefined) ? %s.call(%s[%s].encode(%s, %s.call(this.uint32((%s << 3 | 2) >> 0)))) : %s[%s].call(this.uint32(%s << 3 | %s), %s);", WIRE, WRITER_LDELIM, ROOT, TYPE, MESSAGE, WRITER_FORK, FIELD_ID, WRITER_FUNCTIONS, TYPE, FIELD_ID, WIRE, MESSAGE).subIndent()
            .pushLine("}").subIndent()
        .pushLine("}")
        .pushLine("for (var i = 0; i < %s.length; i ++) {", TYPES_ARRAY).addIndent()
            .pushLine("%s[%s[i]] = %s.Reader.prototype[%s[i]];", READER_FUNCTIONS, TYPES_ARRAY, PROTOBUF, TYPES_ARRAY)
            .pushLine("%s[%s[i]] = %s.Writer.prototype[%s[i]];", WRITER_FUNCTIONS, TYPES_ARRAY, PROTOBUF, TYPES_ARRAY).subIndent()
        .pushLine("}")
        .pushLine();

    codeGen
        // wrapped function call
        .pushLine("// namespace builder")
        .pushLine("(function _(%s, %s, %s) {", NAMESPACE, PATH, PARENT).addIndent()
            .pushLine("%s = %s || '';", PATH, PATH)
            .pushLine("%s = %s || %s;", PARENT, PARENT, ROOT)
            // iterates namespaces
            .pushLine("for (var i = 0, %s = Object.keys(%s); i < %s.length; i ++) {", KEYS, NAMESPACE, KEYS).addIndent()
                .pushLine("var %s = %s[i];", KEY, KEYS)
                .pushLine("if (Object.keys(%s[%s]).every(function (k) { return Number(k); })) {", NAMESPACE, KEY).addIndent()
                    // pbtype array. create classes to namespace
                    .pushLine("%s[%s] = function(%s, %s) {", PARENT, KEY, FIELD_PAYLOADS, KEY).addIndent();
                        // constructor
                        config.comments && codeGen.pushComments([
                            "Constructor function wrapper for the all protobuf type.",
                            "@constructor",
                            `@param [${PROPERTIES}] Properties to set with`
                        ]);
                    codeGen
                        .pushLine("function %s(%s) {", CLASS_NAME, PROPERTIES).addIndent()
                            // explicitly initialize mutable object/array fields
                            // so that these aren't just inherited from the prototype
                            .pushLine("for (var id in %s) {", FIELD_PAYLOADS).addIndent()
                                .pushLine("var %s = %s[id];", FIELD_PAYLOAD, FIELD_PAYLOADS)
                                .pushLine("// initialize object/array fields")
                                .pushLine("if (%s[1][0] === '{') this[%s[0]] = {};", FIELD_PAYLOAD, FIELD_PAYLOAD)
                                .pushLine("else if (%s[1][0] === '[' || %s[1][0] === '<') this[%s[0]] = [];", FIELD_PAYLOAD, FIELD_PAYLOAD, FIELD_PAYLOAD).subIndent()
                            .pushLine("}")
                            .pushLine("if (%s) {", PROPERTIES).addIndent()
                                // omit undefined or null properties
                                .pushLine("for (var %s = Object.keys(%s), i = 0; i < %s.length; ++i)", KEYS, PROPERTIES, KEYS).addIndent()
                                    .pushLine("%s[%s[i]] != null && (this[%s[i]] = %s[%s[i]])", PROPERTIES, KEYS, KEYS, PROPERTIES, KEYS).subIndent().subIndent()
                            .pushLine("}").subIndent()            
                        .pushLine("}")
                        .pushLine()
                        
                        // prototype fields
                        .pushLine("var $%s = {};", NAMESPACE)
                        .pushLine("for (var id in %s) {", FIELD_PAYLOADS).addIndent()
                            .pushLine("var %s = %s[id];", FIELD_PAYLOAD, FIELD_PAYLOADS)
                            .pushLine("var %s = %s[1];", TYPE, FIELD_PAYLOAD)
                            .pushLine("if (%s[0] === '{') {", TYPE).addIndent()
                                .pushLine("%s.prototype[%s[0]] = %s.util.emptyObject;", CLASS_NAME, FIELD_PAYLOAD, PROTOBUF)
                                // special care for map fields
                                .pushLine("// collect all map fields")
                                .pushLine("// { key: value } => { '1': [ '$1', <key>, null ], '2': [ '$2', <value>, null ] }")
                                .pushLine("$%s[%s] = %s.substring(1).split(',')", NAMESPACE, TYPE, TYPE).addIndent()
                                    .pushLine(".map(function (t, i) { return ['$' + (i + 1), t, null] })")
                                    .pushLine(".reduce(function(m, o, i) { m[i + 1] = o; return m; }, {});").subIndent().subIndent()
                            .pushLine("} else if (%s[0] === '[' || %s[0] === '<') {", TYPE, TYPE).addIndent()
                                .pushLine("%s.prototype[%s[0]] = %s.util.emptyArray;", CLASS_NAME, FIELD_PAYLOAD, PROTOBUF).subIndent()
                            .pushLine("} else {").addIndent()
                                .pushLine("%s.prototype[%s[0]] = %s[2];", CLASS_NAME, FIELD_PAYLOAD, FIELD_PAYLOAD).subIndent()
                            .pushLine("}").subIndent()    
                        .pushLine("}")
                        .pushLine()

                        // for map fields there's a namespace implicitly created under current class,
                        // so that we could easily parse it exclusively from decoder
                        .pushLine("// create inner namespace for each map field")
                        .pushLine("_($%s, %s + '.' + %s, %s);", NAMESPACE, PATH, KEY, CLASS_NAME)
                        .pushLine();
                    
                    if (config.create) {
                        // create
                        config.comments && codeGen.pushComments([
                            "Creates a new instance using the specified properties.",
                            "@function create",
                            "@static",
                            `@param [${PROPERTIES}] Properties to set with`,
                            `@returns {${CLASS_NAME}} instance`
                        ]);
                        codeGen
                        .pushLine("%s.create = function(%s) {", CLASS_NAME, PROPERTIES).addIndent()
                            .pushLine("return new %s[%s](%s);", PARENT, KEY, PROPERTIES).subIndent()
                        .pushLine("}")
                        .pushLine();
                    }

                    if (config.decode) {
                        // decode
                        config.comments && codeGen.pushComments([
                            "Decodes a message from the specified reader or buffer.",
                            "@function decode",
                            "@static",
                            `@param {$protobuf.Reader|Uint8Array} ${READER} Reader or buffer to decode from`,
                            `@param {number} ${LENGTH} Message length if known beforehand`,
                            `@returns {${CLASS_NAME}} instance`,
                            "@throws {Error} If the payload is not a reader or valid buffer",
                            "@throws {$protobuf.util.ProtocolError} If required fields are missing"
                        ]);
                        codeGen
                        .pushLine("%s.decode = function(%s, %s) {", CLASS_NAME, READER, LENGTH).addIndent()
                            .pushLine("if (!(%s instanceof %s.Reader)) %s = %s.Reader.create(%s);", READER, PROTOBUF, READER, PROTOBUF, READER)
                            .pushLine("var %s = %s === undefined ? %s.len : %s.pos + %s;", END_POS, LENGTH, READER, READER, LENGTH)
                            .pushLine("var %s = new %s[%s]();", MESSAGE, PARENT, KEY)
                            .pushLine("while (%s.pos < %s) {", READER, END_POS).addIndent()
                                .pushLine("var %s = %s.uint32();", TAG, READER)
                                .pushLine("var %s = %s >>> 3;", FIELD_ID, TAG)
                                .pushLine("if (%s > 0) {", FIELD_ID).addIndent()
                                    .pushLine("var %s = %s[%s][0];", FIELD, FIELD_PAYLOADS, FIELD_ID)
                                    .pushLine("var %s = %s[%s][1];", TYPE, FIELD_PAYLOADS, FIELD_ID)
                                    .pushLine("if (%s[0] === '{') {", TYPE).addIndent()
                                    .pushLine("// map field")
                                        // map fields are inner namespace for current class
                                        .pushLine("if (%s[%s] === %s.util.emptyObject) %s[%s] = {};", MESSAGE, FIELD, PROTOBUF, MESSAGE, FIELD)
                                        .pushLine("// decode map fields from inner namespace")
                                        .pushLine("var $%s = %s[%s][%s].decode(%s, %s.uint32());", MESSAGE, PARENT, KEY, TYPE, READER, READER)
                                        .pushLine("%s[%s][$%s['$1']] = $%s['$2'];", MESSAGE, FIELD, MESSAGE, MESSAGE).subIndent()
                                    .pushLine("} else if (%s[0] === '[' || %s[0] === '<') {", TYPE, TYPE).addIndent()
                                        .pushLine("// repeated field")
                                        .pushLine("%s = %s.substring(1);", TYPE, TYPE)
                                        .pushLine("if (!(%s[%s] && %s[%s].length)) %s[%s] = [];", MESSAGE, FIELD, MESSAGE, FIELD, MESSAGE, FIELD)
                                        // packable? (always check for forward and backward compatiblity)
                                        .pushLine("if (%s[%s] !== undefined && (%s & /*2^3-1=*/7) === 2) {", PACKED_ARRAY, TYPE, TAG).addIndent()
                                            .pushLine("// packed repeated")
                                            .pushLine("var $%s = %s.uint32() + %s.pos;", END_POS, READER, READER)
                                            .pushLine("while (%s.pos < $%s) %s[%s].push(%s['%s'].call(%s, %s));", READER, END_POS, MESSAGE, FIELD, READER_FUNCTIONS, RW_WRAP, READER, TYPE).subIndent()
                                        .pushLine("} else {").addIndent()
                                            .pushLine("%s[%s].push(%s['%s'].call(%s, %s));", MESSAGE, FIELD, READER_FUNCTIONS, RW_WRAP, READER, TYPE).subIndent()
                                        .pushLine("}").subIndent()
                                    .pushLine("} else {").addIndent()
                                        .pushLine("// non-repeated field")
                                        .pushLine("%s[%s] = %s['%s'].call(%s, %s);", MESSAGE, FIELD, READER_FUNCTIONS, RW_WRAP, READER, TYPE).subIndent()
                                    .pushLine("}").subIndent()
                                .pushLine("} else {").addIndent()
                                    .pushLine("// unknown field")
                                    .pushLine("%s.call(%s, %s & /*2^3-1=*/7);", READER_SKIP, READER, TAG).subIndent()
                                .pushLine("}").subIndent()
                            .pushLine("}")
                            .pushLine("return %s;", MESSAGE).subIndent()
                        .pushLine("}")
                        .pushLine();

                        if (config.delimited) {
                            // decodeDelimited
                            config.comments && codeGen.pushComments([
                                "Decodes a message from the specified reader or buffer, length delimited.",
                                "@function decodeDelimited",
                                "@static",
                                `@param {$protobuf.Reader|Uint8Array} ${READER} Reader or buffer to decode from`,
                                `@param {number} ${LENGTH} Message length if known beforehand`,
                                `@returns {${CLASS_NAME}} instance`,
                                "@throws {Error} If the payload is not a reader or valid buffer",
                                "@throws {$protobuf.util.ProtocolError} If required fields are missing"
                            ]);
                            codeGen
                            .pushLine("%s.decodeDelimited = function(%s) {", CLASS_NAME, READER).addIndent()
                                .pushLine("if (!(%s instanceof %s.Reader)) %s = %s.Reader.create(%s);", READER, PROTOBUF, READER, PROTOBUF, READER)
                                .pushLine("return this.decode(%s, %s.uint32());", READER, READER).subIndent()
                            .pushLine("}")
                            .pushLine();
                        }
                    }

                    if (config.encode) {
                        // encode
                        config.comments && codeGen.pushComments([
                            `Encodes the specified ${CLASS_NAME} message. Does not implicitly verify messages.`,
                            "@function encode",
                            "@static",
                            `@param {${CLASS_NAME}} ${MESSAGE} or plain object to encode`,
                            `@param {$protobuf.Writer} ${WRITER} Writer to encode to`,
                            "@returns {$protobuf.Writer} Writer"
                        ]);
                        codeGen.pushLine("%s.encode = function(%s, %s) {", CLASS_NAME, MESSAGE, WRITER).addIndent()
                            .pushLine("if (!%s) %s = %s.Writer.create();", WRITER, WRITER, PROTOBUF)
                            .pushLine("for (var %s in %s) {", FIELD_ID, FIELD_PAYLOADS).addIndent()
                                .pushLine("var %s = %s[%s][0];", FIELD, FIELD_PAYLOADS, FIELD_ID)
                                .pushLine("var %s = %s[%s][1];", TYPE, FIELD_PAYLOADS, FIELD_ID)
                                .pushLine("if (%s[0] === '{') {", TYPE).addIndent()
                                    // map fields are inner namespace for current class
                                    .pushLine("// map field")
                                    .pushLine("if (%s[%s] != null && %s.hasOwnProperty(%s)) {", MESSAGE, FIELD, MESSAGE, FIELD).addIndent()
                                        .pushLine("for (var i = 0, %s = Object.keys(%s[%s]); i < %s.length; ++ i) {", KEYS, MESSAGE, FIELD, KEYS).addIndent()
                                            .pushLine("%s.call(%s.uint32((%s << 3 | 2) >> 0));", WRITER_FORK, WRITER, FIELD_ID)
                                            .pushLine("// encode map fields from inner namespace")
                                            .pushLine("%s[%s][%s].encode({ '$1': %s[i], '$2': %s[%s][%s[i]] }, %s).ldelim();", PARENT, KEY, TYPE, KEYS, MESSAGE, FIELD, KEYS, WRITER).subIndent()
                                        .pushLine("}").subIndent()
                                    .pushLine("}").subIndent()
                                .pushLine("} else if (%s[0] === '[' || %s[0] === '<') {", TYPE, TYPE).addIndent()
                                    .pushLine("// repeated field")
                                    .pushLine("var %s = %s[0] === '<';", IS_PACKED, TYPE)
                                    .pushLine("%s = %s.substring(1);", TYPE, TYPE)
                                    .pushLine("var %s = %s[%s];", REPEATED_FIELD, MESSAGE, FIELD)
                                    .pushLine("if (%s != null && %s.length) {", REPEATED_FIELD, REPEATED_FIELD).addIndent()
                                        // a type is packable only if it is specified in types.packed
                                        .pushLine("if (%s && %s[%s] !== undefined) {", IS_PACKED, PACKED_ARRAY, TYPE).addIndent()
                                            .pushLine("// packed repeated")
                                            .pushLine("%s.call(%s.uint32((%s << 3 | 2) >> 0));", WRITER_FORK, WRITER, FIELD_ID)
                                            .pushLine("for (var i = 0; i < %s.length; i ++) %s[%s].call(%s, %s[i]);", REPEATED_FIELD, WRITER_FUNCTIONS, TYPE, WRITER, REPEATED_FIELD)
                                            .pushLine("%s.ldelim();", WRITER).subIndent()
                                        .pushLine("} else {").addIndent()
                                            .pushLine("for (var i = 0; i < %s.length; i ++) %s['%s'].call(%s, %s, %s[i], %s)", REPEATED_FIELD, WRITER_FUNCTIONS, RW_WRAP, WRITER, TYPE, REPEATED_FIELD, FIELD_ID).subIndent()
                                        .pushLine("}").subIndent()
                                    .pushLine("}").subIndent()
                                .pushLine("} else {").addIndent()
                                    .pushLine("// non-repeated field")
                                    .pushLine("if (%s[%s] != null && %s.hasOwnProperty(%s)) {", MESSAGE, FIELD, MESSAGE, FIELD).addIndent()
                                        .pushLine("%s['%s'].call(%s, %s, %s[%s], %s);", WRITER_FUNCTIONS, RW_WRAP, WRITER, TYPE, MESSAGE, FIELD, FIELD_ID).subIndent()
                                    .pushLine("}").subIndent()
                                .pushLine("}").subIndent()
                            .pushLine("}")
                            .pushLine("return %s;", WRITER).subIndent()
                        .pushLine("}")
                        .pushLine();
                        
                        if (config.delimited) {
                            // encodeDelimited
                            config.comments && codeGen.pushComments([
                                `Encodes the specified ${CLASS_NAME} message, length delimited. Does not implicitly verify messages.`,
                                "@function encode",
                                "@static",
                                `@param {${CLASS_NAME}} ${MESSAGE} or plain object to encode`,
                                `@param {$protobuf.Writer} ${WRITER} Writer to encode to`,
                                "@returns {$protobuf.Writer} Writer"
                            ]);
                            codeGen
                            .pushLine("%s.encodeDelimited = function(%s, %s) {", CLASS_NAME, MESSAGE, WRITER).addIndent()
                                .pushLine("return this.encode(%s, %s).ldelim();", MESSAGE, WRITER).subIndent()
                            .pushLine("}")
                            .pushLine();
                        }
                    }

                // return constructor
                codeGen
                    .pushLine("return %s;", CLASS_NAME).subIndent()
                    // passing module[key], key to create class
                .pushLine("}(%s[%s], %s);", NAMESPACE, KEY, KEY)
                // exposing 'A.B.C' like string literal index path to ROOT
                // helping encode/decode functions to index with all others pbtype
                .pushLine("// exposing class to %s", ROOT)
                .pushLine("%s[%s + '.' + %s] = %s[%s];", ROOT, PATH, KEY, PARENT, KEY).subIndent()
            .pushLine("} else {").addIndent()
                // passing module, path, root to create namespace
                .pushLine("%s[%s] = _(%s[%s], %s ? %s + '.' + %s : %s, %s[%s] || {});", PARENT, KEY, NAMESPACE, KEY, PATH, PATH, KEY, KEY, NAMESPACE, KEY).subIndent()
            .pushLine("}").subIndent()
        .pushLine("}")
        .pushLine("return %s;", PARENT).subIndent()
    .pushLine("})({").addIndent();
    
    // passing namespaces map as params
    writeNamespace(codeGen, root, true);
    
    // closing brackets
    codeGen.subIndent()
    .pushLine("});")
    .pushLine()
    .pushLine("// exposing '%s' to global/window", root.name)
    .pushLine("%s.util.global['%s'] = %s['%s'];", PROTOBUF, root.name, ROOT, root.name);

    callback(null, codeGen.toString());
}

// namespaces properties array
function writeNamespace(codeGen: SimpleCodeGen, ns: protobuf.NamespaceBase, isLastOne: boolean) {
    if (ns instanceof protobuf.Type) {
        let props: any = {};
        let maxFieldId = Math.max(...Object.keys(ns.fieldsById).map(Number));
        // 1-based field id. ignore absent fields.
        for (var id = 1; id <= maxFieldId; id ++) {
            let field = ns.fieldsById[id];            
            if (field) {
                // don't use long while generating field's default value
                field.long = false;
                field.resolved = false;
                field.resolve();

                let fieldAttr: any[] = [];
                fieldAttr.push(field.name);
                let type = field.resolvedType ? field.resolvedType.fullName : field.type;
                if (field.map) {
                    // map field is marked by a heading '{'
                    // keyType and valueType comma delimited
                    let mapField: protobuf.MapField = <any>field;
                    fieldAttr.push(`{${mapField.keyType},${type}`);
                    // map field's default value set to null here
                    fieldAttr.push(null);
                } else if (field.repeated) {
                    // repeated field is marked by a heading '[', or '<' if packed
                    fieldAttr.push(`${field.packed ? '<' : '['}${type}`);
                    // repeated field's default value set to null here
                    fieldAttr.push(null);
                } else {
                    fieldAttr.push(type);
                    fieldAttr.push(field.defaultValue);
                }
                props[id] = fieldAttr;
            }
        }
        codeGen.pushLine("%s: %j%s", ns.name, props, isLastOne ? '' : ',');
    } else {
        if (!ns.name) throw new Error('namespace needs a name');

        codeGen.pushLine("%s: {", ns.name).addIndent();
        // sort before iteration to avoid meanless modification to VCS
        ns.nestedArray.sort((a, b) => a.name.localeCompare(b.name));
        ns.nestedArray.forEach((nested, index, arr) => {
            if (nested instanceof protobuf.Namespace) {
                writeNamespace(codeGen, nested, index === arr.length - 1);
            }
        });
        codeGen.subIndent().pushLine("}%s", isLastOne ? '' : ',');
    }
}

module.exports = static_mini;