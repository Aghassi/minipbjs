/**
 * DO NOT EDIT
 * -- this file is generated by minipbjs v0.1.2
 */ 

var $root = protobuf.roots;

// type system from protobuf
// notice: minimal build protobuf library does not contains 'types'
var $wires = protobuf.types ? protobuf.types.basic : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0, 'string': 2, 'bytes': 2 };
var $packed = protobuf.types ? protobuf.types.packed : { 'double': 1, 'float': 5, 'int32': 0, 'uint32': 0, 'sint32': 0, 'fixed32': 5, 'sfixed32': 5, 'int64': 0, 'uint64': 0, 'sint64': 0, 'fixed64': 1, 'sfixed64': 1, 'bool': 0 };
var $types = Object.keys($wires);

// shorthands
var $rskip   = protobuf.Reader.prototype.skipType;
var $wldelim = protobuf.Writer.prototype.ldelim;
var $wfork   = protobuf.Writer.prototype.fork;

var $reader = {
    ['$']: function(type) {
        return $reader[type] ? $reader[type].call(this) : $root[type].decode(this, this.uint32());
    }
}, $writer = {
    ['$']: function(type, message, id) {
        var wire = $wires[type];
        return (wire === undefined) ? $wldelim.call($root[type].encode(message, $wfork.call(this.uint32((id << 3 | 2) >> 0)))) : $writer[type].call(this.uint32(id << 3 | wire), message);
    }
}
for (var i = 0; i < $types.length; i ++) {
    $reader[$types[i]] = protobuf.Reader.prototype[$types[i]];
    $writer[$types[i]] = protobuf.Writer.prototype[$types[i]];
}

// namespace builder
(function _(namespace, path, parent) {
    path = path || '';
    parent = parent || $root;
    for (var i = 0, keys = Object.keys(namespace); i < keys.length; i ++) {
        var key = keys[i];
        if (Object.keys(namespace[key]).every(function (k) { return Number(k); })) {
            parent[key] = function(payloads, key) {
                /**
                 * Constructor function wrapper for the all protobuf type.
                 * @constructor
                 * @param [props] Properties to set with
                 */
                function C(props) {
                    for (var id in payloads) {
                        var payload = payloads[id];
                        // initialize object/array fields
                        if (payload[1][0] === '{') this[payload[0]] = {};
                        else if (payload[1][0] === '[' || payload[1][0] === '<') this[payload[0]] = [];
                    }
                    if (props) {
                        for (var keys = Object.keys(props), i = 0; i < keys.length; ++i)
                            props[keys[i]] != null && (this[keys[i]] = props[keys[i]])
                    }
                }

                var $namespace = {};
                for (var id in payloads) {
                    var payload = payloads[id];
                    var type = payload[1];
                    if (type[0] === '{') {
                        C.prototype[payload[0]] = protobuf.util.emptyObject;
                        // collect all map fields
                        // { key: value } => { '1': [ '$1', <key>, null ], '2': [ '$2', <value>, null ] }
                        $namespace[type] = type.substring(1).split(',')
                            .map(function (t, i) { return ['$' + (i + 1), t, null] })
                            .reduce(function(m, o, i) { m[i + 1] = o; return m; }, {});
                    } else if (type[0] === '[' || type[0] === '<') {
                        C.prototype[payload[0]] = protobuf.util.emptyArray;
                    } else {
                        C.prototype[payload[0]] = payload[2];
                    }
                }

                // create inner namespace for each map field
                _($namespace, path + '.' + key, C);

                /**
                 * Creates a new instance using the specified properties.
                 * @function create
                 * @static
                 * @param [props] Properties to set with
                 * @returns {C} instance
                 */
                C.create = function(props) {
                    return new parent[key](props);
                }

                /**
                 * Decodes a message from the specified reader or buffer.
                 * @function decode
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decode = function(reader, length) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length;
                    var message = new parent[key]();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        var id = tag >>> 3;
                        if (id > 0) {
                            var field = payloads[id][0];
                            var type = payloads[id][1];
                            if (type[0] === '{') {
                                // map field
                                if (message[field] === protobuf.util.emptyObject) message[field] = {};
                                // decode map fields from inner namespace
                                var $message = parent[key][type].decode(reader, reader.uint32());
                                message[field][$message['$1']] = $message['$2'];
                            } else if (type[0] === '[' || type[0] === '<') {
                                // repeated field
                                type = type.substring(1);
                                if (!(message[field] && message[field].length)) message[field] = [];
                                if ($packed[type] !== undefined && (tag & /*2^3-1=*/7) === 2) {
                                    // packed repeated
                                    var $end = reader.uint32() + reader.pos;
                                    while (reader.pos < $end) message[field].push($reader['$'].call(reader, type));
                                } else {
                                    message[field].push($reader['$'].call(reader, type));
                                }
                            } else {
                                // non-repeated field
                                message[field] = $reader['$'].call(reader, type);
                            }
                        } else {
                            // unknown field
                            $rskip.call(reader, tag & /*2^3-1=*/7);
                        }
                    }
                    return message;
                }

                /**
                 * Decodes a message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} length Message length if known beforehand
                 * @returns {C} instance
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                C.decodeDelimited = function(reader) {
                    if (!(reader instanceof protobuf.Reader)) reader = protobuf.Reader.create(reader);
                    return this.decode(reader, reader.uint32());
                }

                /**
                 * Encodes the specified C message. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encode = function(message, writer) {
                    if (!writer) writer = protobuf.Writer.create();
                    for (var id in payloads) {
                        var field = payloads[id][0];
                        var type = payloads[id][1];
                        if (type[0] === '{') {
                            // map field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                for (var i = 0, keys = Object.keys(message[field]); i < keys.length; ++ i) {
                                    $wfork.call(writer.uint32((id << 3 | 2) >> 0));
                                    // encode map fields from inner namespace
                                    parent[key][type].encode({ '$1': keys[i], '$2': message[field][keys[i]] }, writer).ldelim();
                                }
                            }
                        } else if (type[0] === '[' || type[0] === '<') {
                            // repeated field
                            var packed = type[0] === '<';
                            type = type.substring(1);
                            var array = message[field];
                            if (array != null && array.length) {
                                if (packed && $packed[type] !== undefined) {
                                    // packed repeated
                                    $wfork.call(writer.uint32((id << 3 | 2) >> 0));
                                    for (var i = 0; i < array.length; i ++) $writer[type].call(writer, array[i]);
                                    writer.ldelim();
                                } else {
                                    for (var i = 0; i < array.length; i ++) $writer['$'].call(writer, type, array[i], id)
                                }
                            }
                        } else {
                            // non-repeated field
                            if (message[field] != null && message.hasOwnProperty(field)) {
                                $writer['$'].call(writer, type, message[field], id);
                            }
                        }
                    }
                    return writer;
                }

                /**
                 * Encodes the specified C message, length delimited. Does not implicitly verify messages.
                 * @function encode
                 * @static
                 * @param {C} message or plain object to encode
                 * @param {$protobuf.Writer} writer Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                C.encodeDelimited = function(message, writer) {
                    return this.encode(message, writer).ldelim();
                }

                return C;
            }(namespace[key], key);
            // exposing class to $root
            $root[path + '.' + key] = parent[key];
        } else {
            parent[key] = _(namespace[key], path ? path + '.' + key : key, namespace[key] || {});
        }
    }
    return parent;
})({
    mini: {
        bar: {
            Bar: {"1":["a","string","x"],"2":["b","uint64",100],"3":["c","<uint32",null],"4":["d","[uint32",null],"5":["e","<mini.bar.Foo",null],"6":["f","<mini.bar.Foo",null],"7":["g","{uint32,bool",null],"8":["h","{string,mini.bar.Foo",null],"10":["j","mini.bar.Puz",null]},
            Foo: {"1":["a","uint32",0],"2":["b","string",""]},
            Puz: {"1":["a","uint32",0],"2":["b","string",""],"3":["c","<string",null]}
        },
        foo: {
            Bar: {"1":["a","string","x"],"2":["b","uint64",100],"3":["c","<uint32",null],"4":["d","[uint32",null],"5":["e","<mini.foo.Foo",null],"6":["f","<mini.foo.Foo",null],"7":["g","{uint32,bool",null],"8":["h","{string,mini.foo.Foo",null],"10":["j","mini.foo.Puz",null]},
            Foo: {"1":["a","uint32",0],"2":["b","string",""]},
            Puz: {"1":["a","uint32",200],"2":["b","string",""],"3":["c","<string",null]}
        }
    }
});

// exposing 'mini' to global/window
protobuf.util.global['mini'] = $root['mini'];